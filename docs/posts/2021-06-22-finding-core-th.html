<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="x-ua-compatible" content="ie=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Marco Zocca - Finding the Core of an expression using Template Haskell and a custom GHC Core plugin</title>
        <link rel="stylesheet" href="../css/default.css" />
    </head>
    <body>


        <div class="container content">

        <header class="masthead">
            <div class="row">
              <div class="col-sm-6">
                    <h2 class="masthead-title">
                      <a href="../index.html" title="Home">Marco Zocca</a>
                </h2>
              </div>
              <div class="col-sm-6">
                    <h4 class="masthead-title" style="text-align: right;">
                      <a href="../about.html" title="About">About</a>
                  &nbsp;  
                      <!-- <a href='https://erikbern.com/top-posts' title='Top posts'>Top posts</a> -->
                  &nbsp;
                      <a class="icon-github-squared" href="../open-source" title="Open source">Open Source</a>
                  &nbsp;
                      <a href="../archive.html">Archive</a>
                </h4>
              </div>
            </div>
              </header>


        <main role="main">
            <h1>Finding the Core of an expression using Template Haskell and a custom GHC Core plugin</h1>
            <article class="post">
    <section class="header">
        June 22, 2021
    </section>
    <section>
        <h2 id="introduction">Introduction</h2>
<p><a href="https://www.haskell.org/ghc/">GHC</a> is a wonderful <del>compiler</del> platform for writing compilers and languages. In addition to Haskell offering convenient syntactic abstractions for creating domain-specific languages, the language itself and the internals of the compiler can be extended in many ways, which let users come up with mind-bending innovations in <a href="http://conal.net/papers/compiling-to-categories/compiling-to-categories.pdf">scientific computing</a>, <a href="https://hackage.haskell.org/package/inspection-testing">testing</a> and <a href="https://haskellwingman.dev/">code editing</a>, among many other examples.</p>
<p>The compiler offers a <a href="https://downloads.haskell.org/ghc/latest/docs/html/users_guide/extending_ghc.html#compiler-plugins">plugin system</a> that lets users customize various aspects of the syntax analysis, typechecking and compilation phases, without having to rebuild the compiler itself.</p>
<p>While writing a GHC plugin that lets the user analyze and transform the Core representation of certain Haskell expressions, I found myself in need of a specific bit of machinery: <em>how can the user tell the compiler which expression to look for?</em> Moreover, how to map the names of user-defined terms to the internal representation used by the compiler?</p>
<p>It turns out <code>inspection-testing</code> provides this functionality as part of its user interface, and I will document it here both to consolidate its details in my head and so that others might learn from it in the future.</p>
<p>This post will also introduce concepts from both the <code>ghc</code> and <code>template-haskell</code> libraries as needed, so it should be useful to those who, like me, had zero experience in compiler internals until the other day.</p>
<p>Note on reproducibility : here I’m referring to GHC 9.0.1, some modules changed paths since GHC series 8. I’ve only omitted a few easy imports and definitions from <code>base</code>, which you can fill in as an exercise ;)</p>
<p>So, let’s dive into the compiler !</p>
<h2 id="finding-the-name-of-declarations-with-template-haskell">Finding the <code>Name</code> of declarations with template Haskell</h2>
<p>A template-haskell <a href="https://hackage.haskell.org/package/template-haskell-2.17.0.0/docs/Language-Haskell-TH.html#t:Name"><code>Name</code></a> represents .. the name of declarations, expressions etc. in the syntax tree.</p>
<p>Resolving a top-level declaration into its <code>Name</code> requires a little bit of metaprogramming, enabled by the <code>{-# LANGUAGE TemplateHaskell #-}</code> extension. With that, we can use the special syntax with a single or double quote to refer to values or types respectively (made famous by <code>lens</code> in <a href="https://hackage.haskell.org/package/lens-5.0.1/docs/Control-Lens-Combinators.html#v:makeLenses"><code>makeLenses</code></a> ’’Foo).</p>
<h2 id="passing-names-to-later-stages-of-the-compilation-pipeline">Passing <code>Name</code>s to later stages of the compilation pipeline</h2>
<p>This is half of the trick: the <code>Name</code> we just found (and any other metadata that might be interesting to our plugin), is packed and serialized into a GHC <a href="http://downloads.haskell.org/~ghc/latest/docs/html/users_guide/extending_ghc.html#source-annotations">ANNotation</a> via <a href="https://hackage.haskell.org/package/template-haskell-2.17.0.0/docs/Language-Haskell-TH-Syntax.html#v:liftData"><code>liftData</code></a>, which is inserted as a new top-level declaration by a template Haskell action (i.e. a function that returns in the <code>Q</code> monad).</p>
<p>Annotations can also be attached by the user to declarations, types and modules, but this method does so programmatically.</p>
<p>The resulting function has a type signature similar to this : <code>Name -&gt; Q [Dec]</code>, i.e. given a <code>Name</code> it will produce a list of new declarations <code>Dec</code> at compile time.</p>
<p>If we’re only interested in attaching a <code>Name</code> to the annotation, we just need :</p>
<p>{% highlight haskell %}
{-# language DeriveDataTypeable #-}
import Data.Data (Data)
import Language.Haskell.TH (Name, Loc, AnnTarget(..), Pragma(..), Dec(..), location, Q, Exp(..))
import Language.Haskell.TH.Syntax (liftData)</p>
<p>– our annotation payload type
data Target = MkTarget { tgName :: Name } deriving (Data)</p>
<p>inspect :: Name -&gt; Q [Dec]
inspect n = do
annExpr &lt;- liftData (MkTarget n)
pure [PragmaD (AnnP ModuleAnnotation annExpr)]
{% endhighlight %}</p>
<h2 id="picking-out-our-annotation-from-within-the-plugin">Picking out our annotation from within the plugin</h2>
<p>The other half of the trick takes place within the plugin, so we’ll need to import a bunch of modules from <code>ghc</code>-the-library :</p>
<p>{% highlight haskell %}
– ghc
import GHC.Plugins (Plugin, defaultPlugin, CorePlugin, installCoreToDos, pluginRecompile, CommandLineOption, fromSerialized, deserializeWithData, ModGuts(..), Name, CoreExpr, Var, flattenBinds, getName, thNameToGhcName, PluginRecompile(..))
import GHC.Core.Opt.Monad (CoreToDo(..), CorePluginPass, bindsOnlyPass, CoreM, putMsgS, getDynFlags, errorMsg)
import GHC.Core (CoreProgram, CoreBind, Bind(..), Expr(..))
import GHC.Types.Annotations (Annotation(..), AnnTarget(..))
import GHC.Utils.Outputable (Outputable(..), SDoc, showSDoc, (&lt;+&gt;), ppr, text)
– template-haskell
import qualified Language.Haskell.TH.Syntax as TH (Name)
{% endhighlight %}</p>
<p>First, we need a function that looks up all the annotations from the module internals (aptly named <code>ModGuts</code> in ghc) and attempts to decode them via their Data interface. Here we are using a custom <code>Target</code> type defined above, which could carry additional metadata.</p>
<p>{% highlight haskell %}
extractTargets :: ModGuts -&gt; (ModGuts, [Target])
extractTargets guts = (guts’, xs)
where
(anns_clean, xs) = partitionMaybe findTargetAnn (mg_anns guts)
guts’ = guts { mg_anns = anns_clean }
findTargetAnn = 
(Annotation _ payload) -&gt; fromSerialized deserializeWithData payload
_ -&gt; Nothing
{% endhighlight %}</p>
<p>Next, we need to map <code>template-haskell</code> names to the internal GHC namespace, <code>thNameToGhcName</code> to the rescue. If the name can be resolved, <code>lookupTHName</code> will return the corresponding Core <code>Expr</code>ession (i.e. the abstract syntax tree corresponding to the name we picked in the beginning).</p>
<p>{% highlight haskell %}
– Resolve the TH.Name into a GHC Name and look this up within the list of binders in the module guts
lookupTHName :: ModGuts -&gt; TH.Name -&gt; CoreM (Maybe (Var, CoreExpr))
lookupTHName guts thn = thNameToGhcName thn &gt;&gt;= 
Nothing -&gt; do
errorMsg $ text “Could not resolve TH name” &lt;+&gt; text (show thn)
pure Nothing
Just n -&gt; pure $ lookupNameInGuts guts n
where
lookupNameInGuts :: ModGuts -&gt; Name -&gt; Maybe (Var, CoreExpr)
lookupNameInGuts guts n = listToMaybe
[ (v,e)
| (v,e) &lt;- flattenBinds (mg_binds guts)
, getName v == n
]
{% endhighlight %}</p>
<h2 id="a-custom-ghc-core-plugin">A custom GHC Core plugin</h2>
<p>As noted above, a GHC plugin can customize many aspects of the compilation process. Here we are interested in the compiler phase that produces Core IR, so we’ll only have to modify the <code>installCoreToDos</code> field of the <code>defaultPlugin</code> value provided by <code>ghc</code> by providing our own version :</p>
<p>{% highlight haskell %}
– module MyPlugin</p>
<p>plugin :: Plugin
plugin = defaultPlugin {
installCoreToDos = install – will be defined below
, pluginRecompile = _ -&gt; pure NoForceRecompile
}
{% endhighlight %}</p>
<p>As a minimal example, let’s pretty-print the Core expression corresponding to the <code>Name</code> we just found:</p>
<p>{% highlight haskell %}
– Print the Core representation of the expression that has the given Name
printCore :: ModGuts -&gt; TH.Name -&gt; CoreM ()
printCore guts thn = do
mn &lt;- lookupTHName guts thn
case mn of
Just (_, coreexpr) -&gt; do
dflags &lt;- getDynFlags
putMsgS $ showSDoc dflags (ppr coreexpr) – GHC pretty printer
Nothing -&gt; do
errorMsg $ text “Cannot find name” &lt;+&gt; text (show thn)
{% endhighlight %}</p>
<p>All that’s left is to package <code>printCore</code> into our custom implementation of <code>installCoreToDos</code>:</p>
<p>{% highlight haskell %}
– append a ‘CoreDoPluginPass’ at the <em>end</em> of the ‘CoreToDo’ list
install :: [CommandLineOption] -&gt; [CoreToDo] -&gt; CoreM [CoreToDo]
install _ todos = pure (todos ++ [pass])
where
pass = CoreDoPluginPass pname $  guts -&gt; do
let (guts’, targets) = extractTargets guts
traverse_ ( t -&gt; printCore guts’ (tgName t)) targets
pure guts’
pname = “MyPlugin”
{% endhighlight %}</p>
<p>Here it’s important to stress that <code>install</code> <em>appends</em> our plugin pass to the ones received as input from the upstream compilation pipeline.</p>
<p>Another crucial detail : the name string of the plugin as specified in <code>CoreDoPluginPass</code> <em>must</em> be the full module name where the <code>plugin</code> value is declared.</p>
<h2 id="trying-out-our-plugin">Trying out our plugin</h2>
<p>A GHC plugin can be imported as any other Haskell library in the <code>build-depends</code> section of the Cabal file. While developing a plugin, one should ensure that the test <code>hs-srcs-dirs</code> directory is distinct from that under which the plugin source is defined, so as not to form an import loop.</p>
<p>With this, we can declare a minimal module that imports the TH helper <code>inspect</code> and the plugin as well. Important to note that <code>MyPlugin</code> in the <code>-fplugin</code> option is the name of the Cabal <em>module</em> in which GHC will look for the <code>plugin :: Plugin</code> value (the entry point to our plugin).</p>
<p>{% highlight haskell %}
{-# LANGUAGE TemplateHaskell #-}
{-# OPTIONS_GHC -fplugin=MyPlugin #-}
module PluginTest where</p>
<p>– try building with either type signature for extra fun</p>
<p>f :: Double -&gt; Double -&gt; Double
– f :: Floating a =&gt; a -&gt; a -&gt; a
f = y -&gt; sqrt x + y</p>
<p>inspect ’f
{% endhighlight %}</p>
<p>The output of our custom compiler pass will be interleaved with the rest of the GHC output as part of a clean recompile (e.g. <code>stack clean &amp;&amp; stack build</code>):</p>
<p>{% highlight haskell %}
[1 of 2] Compiling Main
[2 of 2] Compiling PluginTest
 (x [Dmd=&lt;S,1*U(U)&gt;] :: Double) (y [Dmd=&lt;S,1*U(U)&gt;] :: Double) -&gt;
case x of { D# x -&gt;
case y of { D# y -&gt; D# (+## (sqrtDouble# x) y) }
}
{% endhighlight %}</p>
<p>If you squint a bit, you can still see the structure of the original expression <code>\x y = sqrt x + y</code>, enriched with additional annotations.
For example:</p>
<ul>
<li><p>the <code>Dmd=&lt;...&gt;</code> parts are strictness/demand annotations computed for each variable</p></li>
<li><p>the <code>Double -&gt; Double -&gt; Double</code> expression has been made strict (the <code>case</code> branch expressions), and its parameters have been “unboxed” (<a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/GHC-Exts.html#t:Double"><code>D#</code></a> stands for “unboxed double”, i.e. containing the value itself, not a pointer to it)</p></li>
<li><p>correspondingly, both the <a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/GHC-Exts.html#v:-43--35--35-">addition</a> and <a href="https://hackage.haskell.org/package/base-4.15.0.0/docs/GHC-Exts.html#v:sqrtDouble-35-">square root</a> operators have been specialized to those operating on unboxed doubles.</p></li>
</ul>
<p>That’s it! We’ve customized the compiler (without breaking it !), how cool is that?</p>
<h2 id="credits">Credits</h2>
<p>First and foremost a big shout out to all the contributors to GHC who have built a truly remarkable piece of technology we can all enjoy, learn from and be productive with.</p>
<p>Of course, Joachim Breitner for <code>inspection-testing</code> [1]. I still remember the distinct feeling of my brain expanding against my skull after seeing his presentation on this at Zurihac 2017.</p>
<p>Next, I’d like to thank the good folks in the Haskell community for kindly giving exhaustive answers to my questions on r/haskell, the ZuriHac discord server and stackoverflow. Li-yao Xia, Matthew Pickering, Daniel Diaz, David Feuer and others. Matthew has also written a paper [2] and curated a list of references on GHC plugins , which I refer to extensively.</p>
<p>Mark Karpov deserves lots of credit too for writing an excellent reference on template Haskell [3] with lots of worked examples, go and check it out.</p>
<h2 id="references">References</h2>
<ol start="0" type="1">
<li><p><a href="https://gitlab.haskell.org/ghc/ghc/-/wikis/annotations">GHC annotations</a></p></li>
<li><p>J. Breitner, <a href="https://github.com/nomeata/inspection-testing"><code>inspection-testing</code></a></p></li>
<li><p>M. Pickering et al, <a href="https://mpickering.github.io/papers/working-with-source-plugins.pdf">Working with source plugins</a></p></li>
<li><p>M. Karpov, <a href="https://markkarpov.com/tutorial/th.html">Template Haskell tutorial</a></p></li>
</ol>
    </section>
</article>

        </main>

        <footer>
        </footer>

        </div>

        
    </body>
</html>
