<!DOCTYPE html>

<script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>

<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Growing a software architecture with types</title>
  <meta name="description" content="Yesterday evening I made a presentation at a local functional programming meetup regarding my recent experience in building a data ingestion microservice in ...">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://ocramz.github.io/haskell/2017/11/30/growing-software-architecture.html">
  <link rel="alternate" type="application/rss+xml" title="ocramz.github.io" href="https://ocramz.github.io/feed.xml" />
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">ocramz.github.io</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
          <a class="page-link" href="/about/">About</a>
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="post">

  <header class="post-header">
    <h1 class="post-title">Growing a software architecture with types</h1>
    <p class="post-meta">Nov 30, 2017</p>
  </header>

  <article class="post-content">
    <p>Yesterday evening I made a presentation at a <a href="https://www.meetup.com/got-lambda">local functional programming meetup</a> regarding my recent experience in building a data ingestion microservice in Haskell. To tell the truth, I was more concerned with communicating the rationale for my design choices rather than the business application per se, and I wanted to show how (my current understanding of) the language helps (or doesn’t) in structuring a large and realistic application.</p>

<p>This blog post reproduces roughly the presentation, and incorporates some feedback I received and some further thoughts I have had on the matter in the meanwhile. It is written for people who had some prior exposure to Haskell, but I’ll try to keep the exposition as intuitive and beginner-friendly as possible.</p>

<p>My biggest hope is to help beginning Haskellers wrap their heads around a few useful concepts, libraries and good practices, while grounding the examples in a concrete project rather than toy code.</p>

<p>In practical terms, this post will show how to perform HTTP calls, use types and typeclasses to manage application complexity and some aspects of exception handling.</p>

<p>Enjoy!</p>

<h2 id="warm-up-http-connections-and-typeclasses">Warm-up: HTTP connections and typeclasses</h2>

<p>This project uses the excellent <a href="https://hackage.haskell.org/package/req"><code class="highlighter-rouge">req</code></a> library for HTTP connections. It’s very well thought out and documented, so I really recommend it.</p>

<p>The library is structured around a single function called, quite fittingly, <code class="highlighter-rouge">req</code>; its type signature reflects the typeclass-oriented design (i.e. function parameters are constrained to belong to certain sets, rather than being fixed upfront). Let’s focus on the constraint part of the signature:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">req</span> <span class="o">::</span> <span class="p">(</span><span class="kt">HttpResponse</span> <span class="n">response</span><span class="p">,</span> <span class="kt">HttpBody</span> <span class="n">body</span><span class="p">,</span> <span class="kt">HttpMethod</span> <span class="n">method</span><span class="p">,</span>
  <span class="kt">MonadHttp</span> <span class="n">m</span><span class="p">,</span>
  <span class="kt">HttpBodyAllowed</span> <span class="p">(</span><span class="kt">AllowsBody</span> <span class="n">method</span><span class="p">)</span> <span class="p">(</span><span class="kt">ProvidesBody</span> <span class="n">body</span><span class="p">))</span> <span class="o">=&gt;</span> <span class="o">...</span></code></pre></figure>

<p>This should be mentally read: “the type <code class="highlighter-rouge">response</code> must be an instance of the <code class="highlighter-rouge">HttpResponse</code> class, <code class="highlighter-rouge">body</code> and <code class="highlighter-rouge">method</code> are jointly constrained by <code class="highlighter-rouge">HttpBodyAllowed</code> ..”, etc.</p>

<p>As soon as we populate all of <code class="highlighter-rouge">req</code>’s parameter slots, the typechecker infers a more concrete (and understandable) type signature. The following example declares a GET request to a certain address, containing no body or parameters, and requires that the response be returned as a “lazy” <a href="http://hackage.haskell.org/package/bytestring"><code class="highlighter-rouge">bytestring</code></a>.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">requestGet</span> <span class="o">::</span> <span class="kt">MonadHttp</span> <span class="n">m</span> <span class="o">=&gt;</span> <span class="n">m</span> <span class="kt">LB</span><span class="o">.</span><span class="kt">ByteString</span>
<span class="n">requestGet</span> <span class="o">=</span> <span class="kr">do</span>
   <span class="n">r</span> <span class="o">&lt;-</span> <span class="n">req</span>
      <span class="kt">GET</span>
      <span class="p">(</span><span class="n">https</span> <span class="s">"www.meetup.com"</span> <span class="o">/:</span> <span class="s">"got-lambda"</span><span class="p">)</span>
      <span class="kt">NoReqBody</span>
      <span class="n">lbsResponse</span>
      <span class="n">mempty</span>
   <span class="n">return</span> <span class="o">$</span> <span class="n">responseBody</span> <span class="n">r</span>   </code></pre></figure>

<p>The above already requires the user to be familiar with typeclasses, lazy evaluation and a couple standard typeclasses (Monoid and Monad). These are fundamental to Haskell, so it helps seeing them used in context.</p>

<h1 id="aside--inspecting-type-instances-in-ghci">Aside : inspecting type instances in GHCi</h1>

<p>Let’s take the last parameter of <code class="highlighter-rouge">req</code> as a concrete example. It is of type <code class="highlighter-rouge">Option scheme</code>, where <code class="highlighter-rouge">scheme</code> is some type parameter. Now, how do I know what are the right types that can be used here? I always have a GHCi session running in one Emacs tile, so that I can explore interactively the libraries imported by the project I’m working on; in this case, I query for information (by using the <code class="highlighter-rouge">:i</code> GHCi macro) on <code class="highlighter-rouge">Option</code> (the GHCi prompt is represented by the <code class="highlighter-rouge">&gt;</code> character):</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="o">:</span><span class="n">i</span> <span class="kt">Option</span>
<span class="o">...</span>
<span class="kr">instance</span> <span class="kt">Monoid</span> <span class="p">(</span><span class="kt">Option</span> <span class="n">scheme</span><span class="p">)</span> <span class="c1">-- Defined in ‘Network.HTTP.Req’</span>
<span class="kr">instance</span> <span class="kt">QueryParam</span> <span class="p">(</span><span class="kt">Option</span> <span class="n">scheme</span><span class="p">)</span>
  <span class="c1">-- Defined in ‘Network.HTTP.Req’</span></code></pre></figure>

<p>I omitted the first few lines because they are not of immediate interest. The rest of the GHCi response shows what typeclass instances the <code class="highlighter-rouge">Option</code> type satisfies; there we see <code class="highlighter-rouge">Monoid</code> and <code class="highlighter-rouge">QueryParam</code>. The Monoid instance is extremely useful because it provides a type with a “neutral element” (<code class="highlighter-rouge">mempty</code>) and with a binary operation (<code class="highlighter-rouge">mappend</code>) with some closure property (if <code class="highlighter-rouge">a</code> and <code class="highlighter-rouge">b</code> are values of a Monoid type, <code class="highlighter-rouge">mappend a b</code> is of Monoid type as well).</p>

<p>Strings of texts are one familiar example of things with the Monoid property: the empty string (“”) is the neutral element, and appending two strings (<code class="highlighter-rouge">++</code>) is a binary and associative operation, corresponding to <code class="highlighter-rouge">mappend</code>. Other common examples of Monoid are 0 and integer addition, or 1 and integer multiplication.</p>

<p>Back to our function <code class="highlighter-rouge">req</code>; all of this means that since <code class="highlighter-rouge">Option</code> is a Monoid and I simply wish to pass “no parameter” as an argument, I can use <code class="highlighter-rouge">mempty</code> and the concrete type will be inferred automatically.</p>

<h2 id="monadhttp-monadio-and-typeclass-lifting">MonadHttp, MonadIO and typeclass “lifting”</h2>

<p>In the second code snippet above we see that the HTTP response is returned by some computation of type <code class="highlighter-rouge">m</code>, which is constrained to being an instance of <code class="highlighter-rouge">MonadHttp</code> :</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="o">:</span><span class="n">i</span> <span class="kt">MonadHttp</span>
<span class="kr">class</span> <span class="kt">MonadIO</span> <span class="n">m</span> <span class="o">=&gt;</span> <span class="kt">MonadHttp</span> <span class="p">(</span><span class="n">m</span> <span class="o">::</span> <span class="o">*</span> <span class="o">-&gt;</span> <span class="o">*</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">handleHttpException</span> <span class="o">::</span> <span class="kt">HttpException</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
  <span class="o">...</span>
  <span class="cp">{-# MINIMAL handleHttpException #-}</span></code></pre></figure>

<p>.. What does <em>that</em> mean?</p>

<p>Recall that the HTTP protocol uses status codes to communicate the details of connection failure or success. For example, code 200 stands for success, 404 for “Not Found”, etc. The <code class="highlighter-rouge">HttpException</code> type contains a field where such codes are stored, and any type that’s made an instance of <code class="highlighter-rouge">MonadHttp</code> must provide an implementation of <code class="highlighter-rouge">handleHttpException</code> that processes this status.</p>

<p>It’s important to note that <code class="highlighter-rouge">a</code>, the return type of <code class="highlighter-rouge">handleHttpException</code>, is not constrained in any way but may be made to contain whatever information required by the rest of our program logic.</p>

<p>We also see that the parametric type <code class="highlighter-rouge">m</code> is further required to have a <code class="highlighter-rouge">MonadIO</code> instance. Fine, web connections are one form of I/O, so this makes some sense. What may be novel to some readers is that rather than being in the usual “concrete” form <code class="highlighter-rouge">.. -&gt; IO a</code>, the computation is “lifted” to the MonadIO class, thus taking the form <code class="highlighter-rouge">MonadIO m =&gt; .. -&gt; m a</code>. It’s as if we went from saying “a computation of type IO” to “something of <em>any</em> type that can perform IO”.</p>

<p>The <code class="highlighter-rouge">MonadHttp</code> typeclass encodes exactly this: since HTTP connections are a form of I/O, the <code class="highlighter-rouge">MonadHttp</code> constraint <em>entails</em> the <code class="highlighter-rouge">MonadIO</code> constraint; in other words, every type <code class="highlighter-rouge">m</code> that has a <code class="highlighter-rouge">MonadHttp</code> instance <em>must</em> also declare a <code class="highlighter-rouge">MonadIO</code> instance (the compiler will complain otherwise).</p>

<p>We’ll learn about the implications of this way of writing things in the next section.</p>

<h2 id="api-authentication-and-type-families">API authentication and type families</h2>

<p>Many API providers require some form of authentication; during an initial “handshake” phase the client sends its credentials to the server over some secure channel (e.g. encrypted over TLS), which will in turn send back a “token” which will be necessary to perform the actual API calls and which will expire after a set time. This is for example how the OAuth2 authentication protocol works.</p>

<p>In practice, each provider has its own :</p>

<ul>
  <li>Set of credentials</li>
  <li>Authentication/token refresh mechanisms</li>
  <li>Handling of invalid input</li>
  <li>Request rate limiting</li>
  <li>Outage modes</li>
  <li>etc., etc.</li>
</ul>

<p>however the general semantics of this token-based connection are the same for all. This screams for some sort of common interface to hide the details of dealing with the individual providers from the point of view of higher levels of the application code.</p>

<p>One possible way of representing this is with a parametrized type; a way of declaring a computation that is “tagged” by the name of the API provider we’re talking to under the hood. Let’s call this type <code class="highlighter-rouge">Cloud</code>:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>newtype Cloud c a = ...
</code></pre></div></div>

<p>The first type parameter, <code class="highlighter-rouge">c</code>, denotes the API provider “label”, and the second parameter represents the result type of the computation.</p>


  </article>


  
</div>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">ocramz.github.io</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col  footer-col-1">
        <ul class="contact-list">
          <li>ocramz.github.io</li>
          <li><a href="mailto:"></a></li>
        </ul>
      </div>

      <div class="footer-col  footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/ocramz">
              <span class="icon  icon--github">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
                </svg>
              </span>

              <span class="username">ocramz</span>
            </a>
          </li>
          

          
          <li>
            <a href="https://twitter.com/ocramz_yo">
              <span class="icon  icon--twitter">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809
                  c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/>
                </svg>
              </span>

              <span class="username">ocramz_yo</span>
            </a>
          </li>
          
        </ul>
      </div>

      <div class="footer-col  footer-col-3">
        <p class="text">lambdas and large linear systems, oh my
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
