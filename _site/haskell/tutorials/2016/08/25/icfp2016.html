<!DOCTYPE html>

<script src='https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'></script>

<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <title>Folding a paper crane - a solution to the ICFP 2016 programming contest - part 1</title>
  <meta name="description" content="">

  <link rel="stylesheet" href="/css/main.css">
  <link rel="canonical" href="https://ocramz.github.io/haskell/tutorials/2016/08/25/icfp2016.html">
  <link rel="alternate" type="application/rss+xml" title="ocramz.github.io" href="https://ocramz.github.io/feed.xml" />
</head>


  <body>

    <header class="site-header">

  <div class="wrapper">

    <a class="site-title" href="/">ocramz.github.io</a>

    <nav class="site-nav">
      <a href="#" class="menu-icon">
        <svg viewBox="0 0 18 15">
          <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
          <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
          <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
        </svg>
      </a>

      <div class="trigger">
        
          
          <a class="page-link" href="/about/">About</a>
          
        
          
        
          
        
          
        
      </div>
    </nav>

  </div>

</header>


    <div class="page-content">
      <div class="wrapper">
        <div class="post">

  <header class="post-header">
    <h1 class="post-title">Folding a paper crane - a solution to the ICFP 2016 programming contest - part 1</h1>
    <p class="post-meta">Aug 25, 2016</p>
  </header>

  <article class="post-content">
    <p align="center">
<img src="http://oi65.tinypic.com/jzjf3a.jpg" width="450" />
</p>

<h2 id="introduction">Introduction</h2>

<p>The annual ICFP contest ran between August 5 and August 8, 2016 and, even though I couldn’t fully commit to it due to an otherwise busy weekend, I resolved to tackling it in my spare time, using Haskell exclusively, in the course of the subsequent days. In this page I will document my solution process and tools, since the resulting application features quite a few techniques that are seldom explained together (parsing, plotting, geometric processing and combinatorial optimization).</p>

<p>Part 1 of this post will be concerned with representing the problem semantics, parsing with <code>attoparsec</code> and plotting with <code>diagrams</code>.</p>

<p>The <a href="https://icfpc2016.blogspot.se/2016/08/task-description.html">task description</a> can be found on the official blog, along with a few updates and the <a href="http://130.211.240.134/problem/list">problem list</a> (for which a free, anonymous registration is required).</p>

<h2 id="the-challenge">The Challenge</h2>

<p>In short: fold an origami.</p>

<p>The origami is defined as a list of coordinates defining the “silhouette” (contour of the folded origami) and segments joining them (folds or sheet edges, the “skeleton” of the origami). The problem is: given an origami, and starting from a square sheet, find the list of folding moves (simple, or “valley-type” folds only are considered) to approximate the given origami silhouette.</p>

<h2 id="parsing-the-problem-specifications">Parsing the problem specifications</h2>

<p>The problems come as plain text files, of which the following is a typical example (Problem 26). I’ve added some comments to clarify what the sections mean :</p>

<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="mi">2</span>               <span class="c1">-- # of silhouettes</span>
<span class="mi">6</span>               <span class="c1">-- # of points of first silhouette</span>
<span class="mi">1</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span>           <span class="c1">-- list of point coordinates of first silhouette</span>
<span class="mi">3</span><span class="o">/</span><span class="mi">8</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="mi">8</span>         <span class="c1">-- ..      </span>
<span class="mi">3</span><span class="o">/</span><span class="mi">8</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="mi">4</span> 
<span class="mi">1</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="o">/</span><span class="mi">8</span>
<span class="mi">1</span><span class="o">/</span><span class="mi">8</span><span class="p">,</span><span class="mi">3</span><span class="o">/</span><span class="mi">8</span>
<span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="mi">4</span>           <span class="c1">-- .. until here</span>
<span class="mi">4</span>               <span class="c1">-- # of points of second silhouette</span>
<span class="mi">1</span><span class="o">/</span><span class="mi">8</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="mi">8</span>         <span class="c1">-- list of point coordinates of second silhouette </span>
<span class="mi">1</span><span class="o">/</span><span class="mi">8</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="mi">4</span>         <span class="c1">-- ..</span>
<span class="mi">1</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="mi">4</span>
<span class="mi">1</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="mi">8</span>
<span class="mi">10</span>              <span class="c1">-- # of segments</span>
<span class="mi">1</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span> <span class="mi">3</span><span class="o">/</span><span class="mi">8</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="mi">8</span>   <span class="c1">-- list of segment endpoint coordinates</span>
<span class="mi">1</span><span class="o">/</span><span class="mi">8</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="mi">8</span> <span class="mi">1</span><span class="o">/</span><span class="mi">8</span><span class="p">,</span><span class="mi">3</span><span class="o">/</span><span class="mi">8</span> <span class="c1">-- ..</span>
<span class="mi">1</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span> <span class="mi">1</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="o">/</span><span class="mi">8</span>
<span class="mi">3</span><span class="o">/</span><span class="mi">8</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="mi">8</span> <span class="mi">3</span><span class="o">/</span><span class="mi">8</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="mi">4</span>
<span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="mi">4</span> <span class="mi">1</span><span class="o">/</span><span class="mi">8</span><span class="p">,</span><span class="mi">3</span><span class="o">/</span><span class="mi">8</span>
<span class="mi">1</span><span class="o">/</span><span class="mi">8</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="mi">8</span> <span class="mi">3</span><span class="o">/</span><span class="mi">8</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="mi">8</span>
<span class="mi">1</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span> <span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="mi">4</span>
<span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="mi">4</span> <span class="mi">3</span><span class="o">/</span><span class="mi">8</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="mi">4</span>
<span class="mi">3</span><span class="o">/</span><span class="mi">8</span><span class="p">,</span><span class="mi">1</span><span class="o">/</span><span class="mi">4</span> <span class="mi">1</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="o">/</span><span class="mi">8</span>
<span class="mi">1</span><span class="o">/</span><span class="mi">8</span><span class="p">,</span><span class="mi">3</span><span class="o">/</span><span class="mi">8</span> <span class="mi">1</span><span class="o">/</span><span class="mi">4</span><span class="p">,</span><span class="mi">3</span><span class="o">/</span><span class="mi">8</span></code></pre></div>

<p>All coordinates are specified as integers or ratios of integers, and should be manipulated as such (which is sensible because we can operate on them without loss of numerical precision, as opposed to manipulating floats).</p>

<p>We immediately notice the need for some sort of conditional parsing: the first line specifies an integer <code>n</code>, which determines how many “Silhouette” stanzas will follow. The last section is the “Skeleton”, i.e. the complete set of segments that form the “x-ray” picture of the folded origami.</p>

<p>If you want to reproduce, create a new project e.g. with <code>stack new</code> and put the following in the <code>Lib</code> module.</p>

<p>First, the requisite boilerplate:</p>

<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">import</span> <span class="nn">Data.Attoparsec.Internal.Types</span> <span class="p">(</span><span class="kt">Parser</span><span class="p">)</span>
<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.Attoparsec.ByteString</span> <span class="k">as</span> <span class="n">PB</span>
<span class="kr">import</span> <span class="nn">Data.Attoparsec.ByteString.Char8</span> <span class="p">(</span><span class="nf">decimal</span><span class="p">,</span> <span class="nf">signed</span><span class="p">,</span> <span class="nf">scientific</span><span class="p">,</span> <span class="nf">digit</span><span class="p">,</span> <span class="nf">number</span><span class="p">,</span> <span class="nf">rational</span><span class="p">,</span> <span class="nf">char</span><span class="p">,</span> <span class="nf">char8</span><span class="p">,</span> <span class="nf">endOfLine</span><span class="p">,</span> <span class="nf">endOfInput</span><span class="p">,</span> <span class="nf">isDigit</span><span class="p">,</span> <span class="nf">isDigit_w8</span><span class="p">,</span> <span class="nf">isEndOfLine</span><span class="p">,</span> <span class="nf">isHorizontalSpace</span><span class="p">)</span>
<span class="kr">import</span> <span class="k">qualified</span> <span class="nn">Data.ByteString</span> <span class="k">as</span> <span class="n">B</span> <span class="p">(</span><span class="kt">ByteString</span><span class="p">,</span> <span class="n">readFile</span><span class="p">)</span>

<span class="kr">import</span> <span class="nn">System.FilePath</span></code></pre></div>

<p>Now, let’s encode the problem specification semantics in some types :</p>

<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">data</span> <span class="kt">Fract</span> <span class="ow">=</span> <span class="kt">Fract</span> <span class="o">!</span><span class="kt">Int</span> <span class="o">!</span><span class="kt">Int</span>
<span class="kr">instance</span> <span class="kt">Eq</span> <span class="kt">Fract</span> <span class="kr">where</span>
  <span class="n">f1</span> <span class="o">==</span> <span class="n">f2</span> <span class="ow">=</span> <span class="n">ratSimp</span> <span class="n">f1</span> <span class="o">==</span> <span class="n">ratSimp</span> <span class="n">f2</span>

<span class="nf">ratSimp</span> <span class="ow">::</span> <span class="kt">Fractional</span> <span class="n">a</span> <span class="ow">=&gt;</span> <span class="kt">Fract</span> <span class="ow">-&gt;</span> <span class="n">a</span>
<span class="nf">ratSimp</span> <span class="p">(</span><span class="kt">Fract</span> <span class="n">n</span> <span class="n">d</span><span class="p">)</span> <span class="ow">=</span> <span class="n">fromIntegral</span> <span class="n">n</span> <span class="o">/</span> <span class="n">fromIntegral</span> <span class="n">d</span></code></pre></div>

<p>Equality of rationals is established by reducing the fraction; the result is in general not an integer. This method is faster than relying on <code>gcd</code> and simplifying, it seems, but we’ll use it only here and for producing plots (not in the solver logic).</p>

<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">data</span> <span class="kt">Point</span> <span class="ow">=</span> <span class="kt">P</span> <span class="kt">Fract</span> <span class="kt">Fract</span> <span class="kr">deriving</span> <span class="kt">Eq</span>

<span class="kr">data</span> <span class="kt">Segment</span> <span class="ow">=</span> <span class="kt">S</span> <span class="kt">Point</span> <span class="kt">Point</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Eq</span><span class="p">,</span> <span class="kt">Show</span><span class="p">)</span>

<span class="kr">data</span> <span class="kt">Silhouette</span> <span class="ow">=</span>
  <span class="kt">Silhouette</span> <span class="p">{</span> <span class="n">numVerticesPoly</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">,</span>
               <span class="n">points</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Point</span><span class="p">]</span>  <span class="p">}</span> <span class="kr">deriving</span> <span class="kt">Eq</span>

<span class="kr">data</span> <span class="kt">Skeleton</span> <span class="ow">=</span>
  <span class="kt">Skeleton</span> <span class="p">{</span> <span class="n">numSegments</span> <span class="ow">::</span> <span class="kt">Int</span><span class="p">,</span>
             <span class="n">segments</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Segment</span><span class="p">]}</span> <span class="kr">deriving</span> <span class="kt">Eq</span>

<span class="kr">data</span> <span class="kt">Problem</span> <span class="ow">=</span> <span class="kt">Problem</span> <span class="p">[</span><span class="kt">Silhouette</span><span class="p">]</span> <span class="kt">Skeleton</span> <span class="kr">deriving</span> <span class="kt">Eq</span></code></pre></div>

<p>For parsing the specification, we rely on the amazing <code>attoparsec</code> package. I import its ByteString module in qualified form as <code>PB</code> to make it easier to follow.</p>

<p>We switch alternatively between applicative and <code>do</code>-based notation. Anyway, <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/src/GHC.Base.html#Monad">since GHC 8, <code>Monad</code>s are indeed <code>Applicative</code>s</a>, so whatever logic one writes in the latter form automatically applies to the former.</p>

<p>Small reminder about the operators: <code>(&lt;$&gt;) :: Functor f =&gt; (a -&gt; b) -&gt; f a -&gt; f b</code> is a synonym for <code>fmap</code>, <code>(&lt;*&gt;) :: Applicative f =&gt; f (a -&gt; b) -&gt; f a -&gt; f b</code> (read “apply”) is the function defining the Applicative class (“evaluate a function with a value if both are wrapped in a context”), whereas <code>(*&gt;) :: Applicative f =&gt; f a -&gt; f b -&gt; f b</code> and <code>(&lt;*) :: Applicative f =&gt; f a -&gt; f b -&gt; f a</code> can be read as “sequence”, i.e. they perform both actions that appear as their arguments and retain the second and first results, respectively.</p>

<p>The following declarations establish the rules for parsing signed fractional values (optionally integers, i.e. fractionals with 1 at the denominator, using the <code>option</code> modifier), then <code>Point</code>s and <code>Segment</code>s based on those.</p>

<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="nf">parseFractional</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">B</span><span class="o">.</span><span class="kt">ByteString</span> <span class="kt">Fract</span>
<span class="nf">parseFractional</span> <span class="ow">=</span>
  <span class="kt">Fract</span> <span class="o">&lt;$&gt;</span> <span class="n">signed</span> <span class="n">decimal</span> <span class="o">&lt;*&gt;</span> <span class="kt">PB</span><span class="o">.</span><span class="n">option</span> <span class="mi">1</span> <span class="p">(</span><span class="n">char8</span> <span class="n">&#39;</span><span class="o">/</span><span class="n">&#39;</span> <span class="o">*&gt;</span> <span class="n">decimal</span><span class="p">)</span>

<span class="nf">parsePoint</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">B</span><span class="o">.</span><span class="kt">ByteString</span> <span class="kt">Point</span>
<span class="nf">parsePoint</span> <span class="ow">=</span> <span class="kt">P</span> <span class="o">&lt;$&gt;</span> <span class="p">(</span><span class="n">parseFractional</span> <span class="o">&lt;*</span> <span class="n">comma</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="n">parseFractional</span>

<span class="nf">parseSegment</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">B</span><span class="o">.</span><span class="kt">ByteString</span> <span class="kt">Segment</span>
<span class="nf">parseSegment</span> <span class="ow">=</span> <span class="kt">S</span> <span class="o">&lt;$&gt;</span> <span class="p">(</span><span class="n">parsePoint</span> <span class="o">&lt;*</span> <span class="n">space</span><span class="p">)</span> <span class="o">&lt;*&gt;</span> <span class="n">parsePoint</span>

<span class="nf">comma</span> <span class="ow">=</span> <span class="n">char8</span> <span class="n">&#39;</span><span class="p">,</span><span class="n">&#39;</span>
<span class="nf">space</span> <span class="ow">=</span> <span class="n">char8</span> <span class="n">&#39;</span> <span class="n">&#39;</span></code></pre></div>

<p>Next, we’ll need some parsing logic for the various sections of the specification file:</p>

<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="nf">parseNumPolys</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">B</span><span class="o">.</span><span class="kt">ByteString</span> <span class="kt">Int</span>
<span class="nf">parseNumPolys</span> <span class="ow">=</span> <span class="n">decimal</span> <span class="o">&lt;*</span> <span class="n">endOfLine</span>

<span class="nf">parseSilhouette</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">B</span><span class="o">.</span><span class="kt">ByteString</span> <span class="kt">Silhouette</span>
<span class="nf">parseSilhouette</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">nvp</span> <span class="ow">&lt;-</span> <span class="n">decimal</span> <span class="o">&lt;*</span> <span class="n">endOfLine</span>
  <span class="n">pp</span> <span class="ow">&lt;-</span> <span class="kt">PB</span><span class="o">.</span><span class="n">many1</span> <span class="p">(</span><span class="n">parsePoint</span> <span class="o">&lt;*</span> <span class="n">endOfLine</span><span class="p">)</span>
  <span class="n">return</span> <span class="o">$</span> <span class="kt">Silhouette</span> <span class="n">nvp</span> <span class="n">pp</span>

<span class="nf">parseSkeleton</span> <span class="ow">::</span> <span class="kt">Parser</span> <span class="kt">B</span><span class="o">.</span><span class="kt">ByteString</span> <span class="kt">Skeleton</span>
<span class="nf">parseSkeleton</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">ns</span> <span class="ow">&lt;-</span> <span class="n">decimal</span> <span class="o">&lt;*</span> <span class="n">endOfLine</span>
  <span class="n">segs</span> <span class="ow">&lt;-</span> <span class="kt">PB</span><span class="o">.</span><span class="n">many1</span> <span class="p">(</span><span class="n">parseSegment</span> <span class="o">&lt;*</span> <span class="n">endOfLine</span><span class="p">)</span>
  <span class="n">return</span> <span class="o">$</span> <span class="kt">Skeleton</span> <span class="n">ns</span> <span class="n">segs</span></code></pre></div>

<p>Notice how easily we can compose elementary parsers into more complex ones. The <code>parseProblem0</code> function reflects the problem specification structure 1:1. Neat!</p>

<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="nf">parseProblem0</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Parser</span> <span class="kt">B</span><span class="o">.</span><span class="kt">ByteString</span> <span class="kt">Problem</span>
<span class="nf">parseProblem0</span> <span class="n">n</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="kr">_</span> <span class="ow">&lt;-</span> <span class="n">decimal</span> <span class="o">*&gt;</span> <span class="n">endOfLine</span>
  <span class="n">sils</span> <span class="ow">&lt;-</span> <span class="kt">PB</span><span class="o">.</span><span class="n">count</span> <span class="n">n</span> <span class="n">parseSilhouette</span>
  <span class="n">skels</span> <span class="ow">&lt;-</span> <span class="n">parseSkeleton</span> <span class="o">&lt;*</span> <span class="n">endOfInput</span>
  <span class="n">return</span> <span class="o">$</span> <span class="kt">Problem</span> <span class="n">sils</span> <span class="n">skels</span></code></pre></div>

<p>or, equivalently,</p>

<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="nf">parseProblem0&#39;</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">Parser</span> <span class="kt">B</span><span class="o">.</span><span class="kt">ByteString</span> <span class="kt">Problem</span>
<span class="nf">parseProblem0&#39;</span> <span class="n">n</span> <span class="ow">=</span>
  <span class="kt">Problem</span> <span class="o">&lt;$&gt;</span>
     <span class="p">(</span><span class="n">decimal</span> <span class="o">*&gt;</span> <span class="n">endOfLine</span> <span class="o">*&gt;</span> <span class="kt">PB</span><span class="o">.</span><span class="n">count</span> <span class="n">n</span> <span class="n">parseSilhouette</span><span class="p">)</span> <span class="o">&lt;*&gt;</span>
     <span class="p">(</span><span class="n">parseSkeleton</span> <span class="o">&lt;*</span> <span class="n">endOfInput</span><span class="p">)</span></code></pre></div>

<p>Next: the implementation of conditional parsing: there is probably a more concise way to say this, but the idea is simple: we must first parse and acquire an integer appearing at the beginning of the file, and with that decide how many times to apply the <code>Silhouette</code> parser (using the <code>count :: Monad m =&gt; Int -&gt; m a -&gt; m [a]</code> modifier).</p>

<p>If parsing succeeds (i.e. our parsers match the structure of the file), the resulting <code>Problem</code> datastructure will be returned (wrapped in a <code>Right</code> constructor).</p>

<p>N.B. the <a href="https://hackage.haskell.org/package/base-4.9.0.0/docs/src/Data.Either.html#line-136"><code>Monad</code> instance of <code>Either</code></a> returns the first <code>Left a</code> value it encounters, in this case a <code>String</code> with the error message.</p>

<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="nf">loadProblem</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="p">(</span><span class="kt">Either</span> <span class="kt">String</span> <span class="kt">Problem</span><span class="p">)</span>
<span class="nf">loadProblem</span> <span class="n">n</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">c</span> <span class="ow">&lt;-</span> <span class="kt">B</span><span class="o">.</span><span class="n">readFile</span> <span class="n">fname</span>
  <span class="kr">let</span> <span class="n">r</span> <span class="ow">=</span> <span class="kt">PB</span><span class="o">.</span><span class="n">parseOnly</span> <span class="n">parseNumPolys</span> <span class="n">c</span>
  <span class="kr">case</span> <span class="n">r</span> <span class="kr">of</span>
    <span class="kt">Left</span> <span class="n">e</span> <span class="ow">-&gt;</span> <span class="ne">error</span> <span class="n">e</span>
    <span class="kt">Right</span> <span class="n">numpolys</span> <span class="ow">-&gt;</span> 
      <span class="n">return</span> <span class="o">$</span> <span class="kt">PB</span><span class="o">.</span><span class="n">parseOnly</span> <span class="p">(</span><span class="n">parseProblem0</span> <span class="n">numpolys</span><span class="p">)</span> <span class="n">c</span>
  <span class="kr">where</span>
     <span class="n">dir</span> <span class="ow">=</span> <span class="s">&quot;problems/&quot;</span>
     <span class="n">fname</span> <span class="ow">=</span> <span class="n">dir</span> <span class="o">&lt;/&gt;</span> <span class="n">show</span> <span class="n">n</span></code></pre></div>

<h2 id="drawing-origami">Drawing origami</h2>

<p>Next, we’ll see how to plot our data; for this I’ll use the equally amazing <code>diagrams</code> package. It is pretty extensive however it also comes with an excellent set of <a href="http://projects.haskell.org/diagrams/tutorials.html">tutorials</a>.</p>

<p>The following goes in a <code>Diag</code> module that imports our <code>Lib</code>.</p>

<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">import</span> <span class="nn">Diagrams.Prelude</span> <span class="k">hiding</span> <span class="p">(</span><span class="kt">P</span><span class="p">,</span> <span class="p">(</span><span class="o">&lt;&gt;</span><span class="p">))</span>
<span class="kr">import</span> <span class="nn">Diagrams.Backend.SVG.CmdLine</span>
<span class="kr">import</span> <span class="nn">Diagrams.Backend.CmdLine</span>

<span class="kr">import</span> <span class="nn">Data.Monoid</span> <span class="p">((</span><span class="o">&lt;&gt;</span><span class="p">))</span>
<span class="kr">import</span> <span class="nn">System.Environment</span> <span class="p">(</span><span class="nf">getArgs</span><span class="p">)</span>

<span class="kr">import</span> <span class="nn">Lib</span> <span class="k">hiding</span> <span class="p">(</span><span class="nf">p2</span><span class="p">)</span></code></pre></div>

<h3 id="from-parsing-to-plotting">From parsing to plotting</h3>

<p>First, some helper functions to convert between our <code>Problem</code> record fields and the <code>diagrams</code> types:</p>

<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="nf">pointToP2</span> <span class="ow">::</span> <span class="kt">Lib</span><span class="o">.</span><span class="kt">Point</span> <span class="ow">-&gt;</span> <span class="kt">P2</span> <span class="kt">Double</span>
<span class="nf">pointToP2</span> <span class="p">(</span><span class="kt">Lib</span><span class="o">.</span><span class="kt">P</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span> <span class="ow">=</span> <span class="n">p2</span> <span class="p">(</span><span class="n">ratSimp</span> <span class="n">x</span><span class="p">,</span> <span class="n">ratSimp</span> <span class="n">y</span><span class="p">)</span>

<span class="nf">pointsToTrail</span> <span class="ow">::</span> <span class="p">[</span><span class="kt">Lib</span><span class="o">.</span><span class="kt">Point</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Trail</span> <span class="kt">V2</span> <span class="kt">Double</span>
<span class="nf">pointsToTrail</span> <span class="ow">=</span>  <span class="n">closeTrail</span> <span class="o">.</span> <span class="n">trailFromVertices</span> <span class="o">.</span> <span class="n">map</span> <span class="n">pointToP2</span>

<span class="nf">segmentToPath</span> <span class="ow">::</span> <span class="kt">Lib</span><span class="o">.</span><span class="kt">Segment</span> <span class="ow">-&gt;</span> <span class="kt">Path</span> <span class="kt">V2</span> <span class="kt">Double</span>
<span class="nf">segmentToPath</span> <span class="p">(</span><span class="kt">S</span> <span class="n">x</span> <span class="n">y</span><span class="p">)</span>  <span class="ow">=</span> <span class="n">pointToP2</span> <span class="n">x</span> <span class="o">~~</span> <span class="n">pointToP2</span> <span class="n">y</span> <span class="ow">::</span> <span class="kt">Path</span> <span class="kt">V2</span> <span class="kt">Double</span></code></pre></div>

<p>Both the <code>Trail</code> and <code>Path</code> types are instances of the internal <code>ToPath</code> class (which later will let us convert them to a <code>Diagram</code> in order to be drawn). Most importantly, a <code>Path</code> is not necessarily continuous, whereas a <code>Trail</code> is assumed to connect the dots.</p>

<p>We use the <code>closeTrail</code> function to render all the sides of the Silhouette polygon since in the dataset the last point in an array doesn’t usually coincide with the starting one.</p>

<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="nf">silhouetteToDiagram</span> <span class="ow">::</span> <span class="kt">Foldable</span> <span class="n">t</span> <span class="ow">=&gt;</span> <span class="n">t</span> <span class="p">[</span><span class="kt">Lib</span><span class="o">.</span><span class="kt">Point</span><span class="p">]</span> <span class="ow">-&gt;</span> <span class="kt">Diagram</span> <span class="kt">B</span>
<span class="nf">silhouetteToDiagram</span> <span class="ow">=</span> <span class="n">strokeTrail</span> <span class="o">.</span> <span class="n">foldMap</span> <span class="n">pointsToTrail</span> 

<span class="nf">skeletonToDiagram</span> <span class="ow">::</span> <span class="kt">Foldable</span> <span class="n">t</span> <span class="ow">=&gt;</span> <span class="n">t</span> <span class="kt">Lib</span><span class="o">.</span><span class="kt">Segment</span> <span class="ow">-&gt;</span> <span class="kt">Diagram</span> <span class="kt">B</span>
<span class="nf">skeletonToDiagram</span> <span class="ow">=</span> <span class="n">stroke</span> <span class="o">.</span> <span class="n">foldMap</span> <span class="n">segmentToPath</span></code></pre></div>

<p>The two functions above subsume summarize all the conversion work between <code>Lib</code> and <code>diagrams</code>.</p>

<h3 id="diagrams-are-monoids">Diagrams are <code>Monoid</code>s</h3>

<p>Diagrams are instances of <code>Monoid</code>, so <code>mappend</code>ing them will yield another Diagram. NB: <code>mconcat :: Monoid a =&gt; [a] -&gt; a</code> is equivalent to <code>mappend</code>ing a list of monoidal values together into a single one.</p>

<p>The next function demonstrates this and also applies some graphical styles to the diagrams (line and filling colors):</p>

<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="nf">diagTot</span> <span class="ow">::</span> <span class="kt">Problem</span> <span class="ow">-&gt;</span> <span class="kt">Diagram</span> <span class="kt">B</span>
<span class="nf">diagTot</span> <span class="n">p</span> <span class="ow">=</span>
  <span class="n">centerXY</span> <span class="o">$</span> <span class="n">mconcat</span> <span class="p">[</span>
      <span class="p">(</span><span class="n">dashingG</span> <span class="p">[</span><span class="mf">0.01</span><span class="p">,</span><span class="mf">0.005</span><span class="p">]</span> <span class="mi">0</span> <span class="o">.</span> <span class="n">lc</span> <span class="n">red</span><span class="p">)</span> <span class="n">skeletonToDiagram</span> <span class="o">$</span> <span class="n">problemSegments</span> <span class="n">p</span>
    <span class="p">,</span> <span class="p">(</span><span class="n">lc</span> <span class="n">black</span> <span class="o">#</span> <span class="n">fc</span> <span class="n">yellow</span><span class="p">)</span> <span class="n">silhouetteToDiagram</span> <span class="o">$</span> <span class="n">problemPoints</span> <span class="n">p</span>
    <span class="p">]</span></code></pre></div>

<p>The only <code>IO</code> required by this program : the Diagrams <code>mainWith</code> function is <a href="http://projects.haskell.org/diagrams/doc/cmdline.html">very versatile</a> but here we simply use it to wrap the file loading <code>IO</code>, to supply the problem number from command line when the program is run.</p>

<p>There are many possibilities for extending the command line input with structured options processing via <code>optparse-applicative</code>, but we don’t need all of that complexity here.</p>

<div class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="nf">main</span> <span class="ow">::</span> <span class="kt">IO</span> <span class="nb">()</span>
<span class="nf">main</span> <span class="ow">=</span> <span class="n">mainWith</span> <span class="n">loadProblemN</span>

<span class="nf">loadProblemN</span> <span class="ow">::</span> <span class="kt">Int</span> <span class="ow">-&gt;</span> <span class="kt">IO</span> <span class="p">(</span><span class="kt">Diagram</span> <span class="kt">B</span><span class="p">)</span>
<span class="nf">loadProblemN</span> <span class="n">n</span> <span class="ow">=</span> <span class="kr">do</span>
  <span class="n">r</span> <span class="ow">&lt;-</span> <span class="n">loadProblem</span> <span class="n">n</span>
  <span class="kr">case</span> <span class="n">r</span> <span class="kr">of</span> <span class="kt">Left</span> <span class="n">e</span> <span class="ow">-&gt;</span> <span class="ne">error</span> <span class="n">e</span>
            <span class="kt">Right</span> <span class="n">p</span> <span class="ow">-&gt;</span> <span class="n">return</span> <span class="o">$</span> <span class="n">diagTot</span> <span class="n">p</span></code></pre></div>

<p>And that’s it really!</p>

<p>At this point we can <code>stack build</code> and, if the Cabal file defines an executable called <code>viz</code> that points to the <code>Diag</code> module it its <code>main-is</code>, calling <code>stack exec viz -- -o viz.svg -w 600 101</code> will render an SVG file of the given width (600 pixels) using the problem specification # 101 (the figure at the top of the page).</p>

<p>This post is already long enough so I’ll close it here, though there are still a couple of kinks to iron in the data preprocessing.</p>

<p>Stay tuned for Part 2, with the solver logic !</p>

  </article>


  


  
</div>

      </div>
    </div>

    <footer class="site-footer">

  <div class="wrapper">

    <h2 class="footer-heading">ocramz.github.io</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col  footer-col-1">
        <ul class="contact-list">
          <li>ocramz.github.io</li>
          <li><a href="mailto:"></a></li>
        </ul>
      </div>

      <div class="footer-col  footer-col-2">
        <ul class="social-media-list">
          
          <li>
            <a href="https://github.com/ocramz">
              <span class="icon  icon--github">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M7.999,0.431c-4.285,0-7.76,3.474-7.76,7.761 c0,3.428,2.223,6.337,5.307,7.363c0.388,0.071,0.53-0.168,0.53-0.374c0-0.184-0.007-0.672-0.01-1.32 c-2.159,0.469-2.614-1.04-2.614-1.04c-0.353-0.896-0.862-1.135-0.862-1.135c-0.705-0.481,0.053-0.472,0.053-0.472 c0.779,0.055,1.189,0.8,1.189,0.8c0.692,1.186,1.816,0.843,2.258,0.645c0.071-0.502,0.271-0.843,0.493-1.037 C4.86,11.425,3.049,10.76,3.049,7.786c0-0.847,0.302-1.54,0.799-2.082C3.768,5.507,3.501,4.718,3.924,3.65 c0,0,0.652-0.209,2.134,0.796C6.677,4.273,7.34,4.187,8,4.184c0.659,0.003,1.323,0.089,1.943,0.261 c1.482-1.004,2.132-0.796,2.132-0.796c0.423,1.068,0.157,1.857,0.077,2.054c0.497,0.542,0.798,1.235,0.798,2.082 c0,2.981-1.814,3.637-3.543,3.829c0.279,0.24,0.527,0.713,0.527,1.437c0,1.037-0.01,1.874-0.01,2.129 c0,0.208,0.14,0.449,0.534,0.373c3.081-1.028,5.302-3.935,5.302-7.362C15.76,3.906,12.285,0.431,7.999,0.431z"/>
                </svg>
              </span>

              <span class="username">ocramz</span>
            </a>
          </li>
          

          
          <li>
            <a href="https://twitter.com/ocramz_yo">
              <span class="icon  icon--twitter">
                <svg viewBox="0 0 16 16">
                  <path fill="#828282" d="M15.969,3.058c-0.586,0.26-1.217,0.436-1.878,0.515c0.675-0.405,1.194-1.045,1.438-1.809
                  c-0.632,0.375-1.332,0.647-2.076,0.793c-0.596-0.636-1.446-1.033-2.387-1.033c-1.806,0-3.27,1.464-3.27,3.27 c0,0.256,0.029,0.506,0.085,0.745C5.163,5.404,2.753,4.102,1.14,2.124C0.859,2.607,0.698,3.168,0.698,3.767 c0,1.134,0.577,2.135,1.455,2.722C1.616,6.472,1.112,6.325,0.671,6.08c0,0.014,0,0.027,0,0.041c0,1.584,1.127,2.906,2.623,3.206 C3.02,9.402,2.731,9.442,2.433,9.442c-0.211,0-0.416-0.021-0.615-0.059c0.416,1.299,1.624,2.245,3.055,2.271 c-1.119,0.877-2.529,1.4-4.061,1.4c-0.264,0-0.524-0.015-0.78-0.046c1.447,0.928,3.166,1.469,5.013,1.469 c6.015,0,9.304-4.983,9.304-9.304c0-0.142-0.003-0.283-0.009-0.423C14.976,4.29,15.531,3.714,15.969,3.058z"/>
                </svg>
              </span>

              <span class="username">ocramz_yo</span>
            </a>
          </li>
          
        </ul>
      </div>

      <div class="footer-col  footer-col-3">
        <p class="text">lambdas and large linear systems, oh my
</p>
      </div>
    </div>

  </div>

</footer>


  </body>

</html>
