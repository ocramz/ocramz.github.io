---
layout: post
title: Folding a paper crane - a solution to the ICFP 2016 programming contest
date: 2016-08-25
categories: Haskell tutorials
---

## Introduction

The annual ICFP contest ran between August 5 and August 8, 2016 and, even though I couldn't fully commit to solving it due to an otherwise busy weekend, I resolved to tackling it in my spare time, using Haskell exclusively, in the course of the subsequent days. In this page I will document my solution process and tools, since the resulting application features quite a few techniques that are seldom documented together (parsing, plotting, geometric processing and combinatorial optimization).

The [task description](https://icfpc2016.blogspot.se/2016/08/task-description.html) can be found on the official blog, along with a few updates and the [problem list](http://130.211.240.134/problem/list) (for which a free, anonymous registration is required).


## The Challenge

In short: fold an origami.

The origami is defined as a list of coordinates defining the "silhouette" (contour of the folded origami) and segments joining them (folds or sheet edges). The problem is: given an origami, and starting from a square sheet, find the list of folding moves (simple, or "valley-type" folds only are considered) to approximate the given origami silhouette.


## Parsing the problem specifications

The following is a typical example (Problem 26):

{% highlight haskell %}

2               -- # of silhouettes
6               -- # of points of 1st silhouette
1/4,0           -- list of point coordinates of 1st silhouette
3/8,1/8         -- ..      
3/8,1/4 
1/4,3/8
1/8,3/8
0,1/4           -- .. until here
4               -- # of points of 2nd silhouette
1/8,1/8         -- list of point coordinates of 2nd silhouette 
1/8,1/4         -- ..
1/4,1/4
1/4,1/8
10              -- # of segments
1/4,0 3/8,1/8   -- list of segment endpoint coordinates
1/8,1/8 1/8,3/8 -- ..
1/4,0 1/4,3/8
3/8,1/8 3/8,1/4
0,1/4 1/8,3/8
1/8,1/8 3/8,1/8
1/4,0 0,1/4
0,1/4 3/8,1/4
3/8,1/4 1/4,3/8
1/8,3/8 1/4,3/8

{% endhighlight %}

All coordinates are specified as integers or ratios of integers, and should be manipulated as such (which is sensible because there will be no loss of numerical precision, as opposed to manipulating floats).

We immediately notice the need for some sort of conditional parsing: the first line specifies an integer `n`, which determines how many "Silhouette" stanzas will follow. The last section is the "Skeleton", i.e. the complete set of segments that form the "x-ray" picture of the folded origami.




First, the requisite boilerplate:

{% highlight haskell %}

import Data.Attoparsec.Internal.Types (Parser)
import qualified Data.Attoparsec.ByteString as PB
import Data.Attoparsec.ByteString.Char8 (decimal, signed, scientific, digit, number, rational, char, char8, endOfLine, endOfInput, isDigit, isDigit_w8, isEndOfLine, isHorizontalSpace)
import qualified Data.ByteString as B (ByteString, hGet, readFile)

{% endhighlight %}


Now, let's encode the problem specification semantics in some types :

{% highlight haskell %}

data Fract = Fract !Int !Int
instance Eq Fract where
  f1 == f2 = ratSimp f1 == ratSimp f2

ratSimp :: Fractional a => Fract -> a
ratSimp (Fract n d) = fromIntegral n / fromIntegral d

{% endhighlight %}

Equality of rationals is established by reducing the fraction; the result is in general not an integer. This method is faster than relying on `gcd` and simplifying, and is the only place where we use `Double`s. 

{% highlight haskell%}

data Point = P Fract Fract deriving Eq

data Segment = S Point Point deriving (Eq, Show)

-- The silhouette is the union set of all its facets at the destination position.

type NumPolys = Int

data Silhouette =
  Silhouette { numVerticesPoly :: Int,
               points :: [Point]  } deriving Eq

-- The skeleton of a solution is the union set of all the facet edges at the destination positions.

data Skeleton =
  Skeleton { numSegments :: Int,
             segments :: [Segment]} deriving Eq

data Problem = Problem [Silhouette] Skeleton deriving Eq

{% endhighlight %}




For parsing the specification, we rely on the amazing `attoparsec` package.

We switch alternatively between applicative and `do`-based notation. Small reminder on the operators: `(<$>) :: Functor f => (a -> b) -> f a -> f b` is a synonym for `fmap`, whereas `(*>) :: Applicative f => f a -> f b -> f b` and `(<*) :: Applicative f => f a -> f b -> f a` can be read as "sequence", i.e. they perform the both actions that appear as their arguments and retain the second and first results, respectively.

The following declarations establish the rules for parsing signed fractional values (optionally integers, i.e. fractionals with 1 at the denominator), then `Point`s and `Segment`s based on those.

{% highlight haskell %}

parseFractional :: Parser B.ByteString Fract
parseFractional =
  Fract <$> PB.option 1 (signed decimal) <*> PB.option 1 (char8 '/' *> decimal)

parsePoint :: Parser B.ByteString Point
parsePoint = P <$> (parseFractional <* comma) <*> parseFractional

parseSegment :: Parser B.ByteString Segment
parseSegment = S <$> (parsePoint <* space) <*> parsePoint

comma = char8 ','
space = char8 ' '

{% endhighlight%}



Next, we'll need some parsing logic for the various sections of the specification file:


{% highlight haskell %}

parseNumPolys :: Parser B.ByteString Int
parseNumPolys = decimal <* endOfLine

parseSilhouette :: Parser B.ByteString Silhouette
parseSilhouette = do
  nvp <- decimal <* endOfLine
  pp <- PB.many1 (parsePoint <* endOfLine)
  return $ Silhouette nvp pp

parseSkeleton :: Parser B.ByteString Skeleton
parseSkeleton = do
  ns <- decimal <* endOfLine
  segs <- PB.many1 (parseSegment <* endOfLine)
  return $ Skeleton ns segs
  

parseProblem0 :: Int -> Parser B.ByteString Problem
parseProblem0 n = do
  _ <- decimal *> endOfLine
  sils <- PB.count n parseSilhouette
  skels <- parseSkeleton <* endOfInput
  return $ Problem sils skels

{% endhighlight %}



There is probably a more concise way to say this, but the idea is simple: we must first parse and acquire an integer appearing at the beginning of the file, and with that decide how many times to apply the `Silhouette` parser (using the `count :: Monad m => Int -> m a -> m [a]` modifier).


{% highlight haskell %}
loadProblem :: Int -> IO (Either String Problem)
loadProblem n = do
  c <- B.readFile fname
  let r = PB.parseOnly parseNumPolys c
  case r of
    Left e -> error e
    Right numpolys -> 
      return $ PB.parseOnly (parseProblem0 numpolys) c
  where
     dir = "problems/"
     fname = dir </> show n

{% endhighlight %}






{% highlight haskell %}


{% endhighlight %}