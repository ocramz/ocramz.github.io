---
layout: post
title: Composable web forms with Applicative
date: 2022-02-12
categories: Haskell web formlets
---

## Introduction

Interactive web applications feature a complex exchange of information between user, frontend and backend; in time the focus of this complexity has shifted from the backend (remember CGI scripts?) to the frontend (javascript, perhaps webassembly one day) and back.

Form-based interaction is an interesting subset of this problem since the input data is well structured and the problem can be formalized in some generality. One such formalization is due to Cooper et al. 

What's a web form? It's really two things : an (HTML) view and a callback that will process the inputs submitted via that view, and possibly produce a new view as a result.

Schematically, `(view, input -> Maybe view')`

We would like this notion to be _composable_ : forms are arrays of typed inputs (e.g. strings, booleans, numbers, dates), and we expect to parse the input into a corresponding arrays of output values.

## Parallel validation

As we saw above, processing user input is half of the "form problem".

Say we want to validate a street address, composed of a street name and number and a postal code. We can think of a few rules that a good street address must satisfy : the street name should be formatted in a certain way, the number should be a positive integer and the postal code made of 5 digits. 

If we write these rules as little validation functions, how can we compose these functions together back into one that validates the address as a whole?

Practically, we are looking to achieve this :

{% highlight haskell %}
validStreetName :: String -> Maybe Street

validStreetNo :: String -> Maybe N

validPostCode :: String -> Maybe PostCode

...

validAddress :: String -> Maybe (Street, Name, PostCode)
{% endhighlight %}


## Applicative

In functional programming languages the notion of `Applicative` functor represents a property of functions that perform more than one independent computation.

In Haskell, this abstraction comes in form of a typeclass with the same name (called "Idiom" originally by McBride and Paterson who discovered it).

{% highlight haskell %}
class Functor f => Applicative f where
  pure :: a -> f a
  (<*>) :: f (a -> b) -> f a -> f b
{% endhighlight %}

"Star" ( `<*>` ) can be seen as a natural composition operator for "curried" functions that have effects, and is exactly what lets us compose validators.

Simplifying somewhat :

{% highlight haskell %}
validAddress :: String -> Maybe (Street, Name, PostCode)
validAddress input = (,,) <$> validStreetName <*> validStreetNo <*> validPostCode
{% endhighlight %}



## Applicative formlets

What's needed now is an (embedded) language that lets us write both form validators and views in terms of the `Applicative` interface. Enter the `Form` DSL : 

{% highlight haskell %}
data Form a where
  FormField :: Field a -> Form a
  Pure :: a -> Form a
  App :: Form (a -> b) -> Form a -> Form b
{% endhighlight %}

The constructors `Pure` and `App` are used to implement the `Applicative` interface for `Form`, whereas `FormField` contains form elements. 

{% highlight haskell %}
data Field a where
  -- | text input field
  Text :: String -> Field String
  -- | switch (binary choice)
  Switch :: String -> Field Bool
{% endhighlight %}

The `String` input to the `Field` constructors is shorthand for a unique reference that will be used to lookup the form inputs from the frontend request body.

We can then declare "smart constructors" for the form elements, that will be labeled with the respective output type : 

{% highlight haskell %}
switch :: String -> Form Bool
switch ref = FormField $ Switch ref 
{% endhighlight %}



## Viewing and evaluating forms

Now we need ways to convert `Form` terms into HTML views and validation callbacks respectively. Concretely, we need to write two functions, `view` and `eval`.

I provide two implementation sketches here, but the details depend on the semantics of the frontend framework that generates form data.


{% highlight haskell %}
view :: Form a -> [Widget]
view = \case
  FormField ff -> pure $ viewField ff
  Pure _ -> pure ""
  App (Pure _) x -> view x
  App f x -> view f <> view x
  
viewField :: Field a -> Widget
viewField = \case
  Switch n -> ...
{% endhighlight %}

Evaluation too builds up the result by recursively unpacking the input form : 

{% highlight haskell %}
eval :: Monad m =>
        FormInputs -- ^ parsed from the message body
     -> Form a -- ^ our form
     -> m (Result [String] a)
eval gfi = \case
  FormField ff -> pure $ evalField gfi ff
  Pure x -> pure (pure x)
  App fm xm -> do
    f <- eval gfi fm
    x <- eval gfi xm
    pure (f <*> x)
    
evalField :: FormInputs -> Field a -> Result [String] a
evalField gfi = \case
  Switch n  ->
    case lookupFormInput n gfi of
      Nothing -> pure False  -- default to False
      Just v -> if v == 'true' then pure True
        else if v == 'false' then pure False
        else
        let err = unwords ["switch '", n, "' : unexpected value", v]
            in Error [err]
{% endhighlight %}

And that's it !


## Conclusion

Hopefully this post managed to convey the power and practicality of the Applicative interface.

The ideas presented here are already consolidated into production-grade libraries, e.g. the `digestive-functors` suite, which comes with adapters for various web frameworks.


## References

McBride, C. and Paterson, R., Idioms: applicative programming with effects https://personal.cis.strath.ac.uk/conor.mcbride/Idiom.pdf

https://hackage.haskell.org/package/base-4.16.0.0/docs/Control-Applicative.html#t:Applicative

Cooper, E. et al., An idiomâ€™s guide to formlets, 2007 https://homepages.inf.ed.ac.uk/wadler/papers/formlets/formlets.pdf

Van der Jeugt, J. `digestive-functors`, https://hackage.haskell.org/package/digestive-functors
