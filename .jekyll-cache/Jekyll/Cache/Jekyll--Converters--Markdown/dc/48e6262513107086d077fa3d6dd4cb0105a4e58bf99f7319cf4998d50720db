I"˚v<p>Yesterday evening I gave a presentation at a <a href="https://www.meetup.com/got-lambda">local functional programming meetup</a> regarding my recent experience in building a data ingestion microservice in Haskell. To tell the truth, I was more concerned with communicating the rationale for my design choices rather than the business application per se, and I wanted to show how (my current understanding of) the language helps (or doesn‚Äôt) in structuring a large and realistic application.</p>

<p>This blog post reproduces roughly the presentation, and incorporates some feedback I received and some further thoughts I have had on the matter in the meanwhile. It is written for people who had some prior exposure to Haskell, but I‚Äôll try to keep the exposition as intuitive and beginner-friendly as possible.</p>

<p>My biggest hope is to help beginning Haskellers wrap their heads around a few useful concepts, libraries and good practices, while grounding the examples in a concrete project rather than toy code.</p>

<p>In practical terms, this post will show how to perform HTTP calls and one possible use of types, typeclasses and monad transformers to manage application complexity.</p>

<p>Enjoy!</p>

<h2 id="warm-up-http-connections-and-typeclasses">Warm-up: HTTP connections and typeclasses</h2>

<p>This project uses the excellent <a href="https://hackage.haskell.org/package/req"><code class="language-plaintext highlighter-rouge">req</code></a> library for HTTP connections. It‚Äôs very well thought out and documented, so I really recommend it.</p>

<p>The library is structured around a single function called, quite fittingly, <code class="language-plaintext highlighter-rouge">req</code>; its type signature reflects the typeclass-oriented design (i.e. function parameters are constrained to belong to certain sets, rather than being fixed upfront). Let‚Äôs focus on the constraint part of the signature:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">req</span> <span class="o">::</span> <span class="p">(</span><span class="kt">HttpResponse</span> <span class="n">response</span><span class="p">,</span> <span class="kt">HttpBody</span> <span class="n">body</span><span class="p">,</span> <span class="kt">HttpMethod</span> <span class="n">method</span><span class="p">,</span>
  <span class="kt">MonadHttp</span> <span class="n">m</span><span class="p">,</span>
  <span class="kt">HttpBodyAllowed</span> <span class="p">(</span><span class="kt">AllowsBody</span> <span class="n">method</span><span class="p">)</span> <span class="p">(</span><span class="kt">ProvidesBody</span> <span class="n">body</span><span class="p">))</span> <span class="o">=&gt;</span> <span class="o">...</span></code></pre></figure>

<p>This should be mentally read: ‚Äúthe type <code class="language-plaintext highlighter-rouge">response</code> must be an instance of the <code class="language-plaintext highlighter-rouge">HttpResponse</code> class, <code class="language-plaintext highlighter-rouge">body</code> and <code class="language-plaintext highlighter-rouge">method</code> are jointly constrained by <code class="language-plaintext highlighter-rouge">HttpBodyAllowed</code> ..‚Äù, etc.</p>

<p>As soon as we populate all of <code class="language-plaintext highlighter-rouge">req</code>‚Äôs parameter slots, the typechecker infers a more concrete (and understandable) type signature. The following example declares a GET request to a certain address, containing no body or parameters, and requires that the response be returned as a ‚Äúlazy‚Äù <a href="http://hackage.haskell.org/package/bytestring"><code class="language-plaintext highlighter-rouge">bytestring</code></a>.</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">requestGet</span> <span class="o">::</span> <span class="kt">MonadHttp</span> <span class="n">m</span> <span class="o">=&gt;</span> <span class="n">m</span> <span class="kt">LB</span><span class="o">.</span><span class="kt">ByteString</span>
<span class="n">requestGet</span> <span class="o">=</span> <span class="kr">do</span>
   <span class="n">r</span> <span class="o">&lt;-</span> <span class="n">req</span>
      <span class="kt">GET</span>
      <span class="p">(</span><span class="n">http</span> <span class="s">"www.datahaskell.org"</span> <span class="o">/:</span> <span class="s">"docs"</span> <span class="o">/:</span> <span class="s">"community"</span> <span class="o">/:</span> <span class="s">"current-environment.html"</span><span class="p">)</span>
      <span class="kt">NoReqBody</span>
      <span class="n">lbsResponse</span>
      <span class="n">mempty</span>
   <span class="n">return</span> <span class="o">$</span> <span class="n">responseBody</span> <span class="n">r</span>   </code></pre></figure>

<p>The above already requires the user to be at least a bit familiar with typeclasses, lazy evaluation and a couple standard typeclasses (ok, just one really: Monoid. The Monad typeclass is implied by structuring the code in a <code class="language-plaintext highlighter-rouge">do</code> block). These are fundamental to Haskell, so it helps seeing them used in context. <code class="language-plaintext highlighter-rouge">req</code> returns in a Monad type because I/O is fundamentally an effect; returning an HTTP response means <em>doing</em> stuff with the network interface, the operating system, and might imply failure of some sort and not return any sensible result, which is distinct from how <em>pure</em> functions behave (i.e. just computing output).</p>

<h1 id="aside--inspecting-type-instances-in-ghci">Aside : inspecting type instances in GHCi</h1>

<p>Let‚Äôs take the last parameter of <code class="language-plaintext highlighter-rouge">req</code> as a concrete example. It is of type <code class="language-plaintext highlighter-rouge">Option scheme</code>, where <code class="language-plaintext highlighter-rouge">scheme</code> is some type parameter. Now, how do I know what are the right types that can be used here? I always have a GHCi session running in one Emacs tile, so that I can explore interactively the libraries imported by the project I‚Äôm working on; in this case, I query for information (by using the <code class="language-plaintext highlighter-rouge">:i</code> GHCi macro) on <code class="language-plaintext highlighter-rouge">Option</code> (the GHCi prompt is represented by the <code class="language-plaintext highlighter-rouge">&gt;</code> character):</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="o">:</span><span class="n">i</span> <span class="kt">Option</span>
<span class="o">...</span>
<span class="kr">instance</span> <span class="kt">Monoid</span> <span class="p">(</span><span class="kt">Option</span> <span class="n">scheme</span><span class="p">)</span> <span class="c1">-- Defined in ‚ÄòNetwork.HTTP.Req‚Äô</span>
<span class="kr">instance</span> <span class="kt">QueryParam</span> <span class="p">(</span><span class="kt">Option</span> <span class="n">scheme</span><span class="p">)</span>
  <span class="c1">-- Defined in ‚ÄòNetwork.HTTP.Req‚Äô</span></code></pre></figure>

<p>I omitted the first few lines because they are not of immediate interest. The rest of the GHCi response shows what typeclass instances the <code class="language-plaintext highlighter-rouge">Option</code> type satisfies; there we see <code class="language-plaintext highlighter-rouge">Monoid</code> and <code class="language-plaintext highlighter-rouge">QueryParam</code>. The Monoid instance is extremely useful because it provides a type with a ‚Äúneutral element‚Äù (<code class="language-plaintext highlighter-rouge">mempty</code>) and with a binary operation (<code class="language-plaintext highlighter-rouge">mappend</code>) with some closure property (if <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">b</code> are values of a Monoid type, <code class="language-plaintext highlighter-rouge">mappend a b</code> is of Monoid type as well).</p>

<p>Strings of texts are one familiar example of things with the Monoid property: the empty string (‚Äú‚Äù) is the neutral element, and appending two strings (<code class="language-plaintext highlighter-rouge">++</code>) is a binary and associative operation, corresponding to <code class="language-plaintext highlighter-rouge">mappend</code>. Other common examples of Monoid are 0 and integer addition, or 1 and integer multiplication.</p>

<p>Back to our function <code class="language-plaintext highlighter-rouge">req</code>; all of this means that since <code class="language-plaintext highlighter-rouge">Option</code> is a Monoid and I simply wish to pass ‚Äúno parameter‚Äù as an argument, I can use <code class="language-plaintext highlighter-rouge">mempty</code> and the concrete type will be inferred automatically.</p>

<h2 id="monadhttp-monadio-and-typeclass-lifting">MonadHttp, MonadIO and typeclass ‚Äúlifting‚Äù</h2>

<p>In the second code snippet above we see that the HTTP response is returned by some computation of type <code class="language-plaintext highlighter-rouge">m</code>, which is constrained to being an instance of <code class="language-plaintext highlighter-rouge">MonadHttp</code>. Let‚Äôs see what GHCi knows about <code class="language-plaintext highlighter-rouge">MonadHttp</code> :</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="o">&gt;</span> <span class="o">:</span><span class="n">i</span> <span class="kt">MonadHttp</span>
<span class="kr">class</span> <span class="kt">MonadIO</span> <span class="n">m</span> <span class="o">=&gt;</span> <span class="kt">MonadHttp</span> <span class="n">m</span> <span class="kr">where</span>
  <span class="n">handleHttpException</span> <span class="o">::</span> <span class="kt">HttpException</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="n">a</span>
  <span class="o">...</span>
  <span class="cp">{-# MINIMAL handleHttpException #-}</span></code></pre></figure>

<p>.. What does <em>that</em> mean?</p>

<p>Recall that the HTTP protocol uses status codes to communicate the details of connection failure or success. For example, code 200 stands for success, 404 for ‚ÄúNot Found‚Äù, etc. The <code class="language-plaintext highlighter-rouge">HttpException</code> type contains a field where such codes are stored, and any type that‚Äôs made an instance of <code class="language-plaintext highlighter-rouge">MonadHttp</code> must provide an implementation of <code class="language-plaintext highlighter-rouge">handleHttpException</code> that processes this status.</p>

<p>It‚Äôs important to note that <code class="language-plaintext highlighter-rouge">a</code>, the return type of <code class="language-plaintext highlighter-rouge">handleHttpException</code>, is not constrained in any way but may be made to contain whatever information required by the rest of our program logic.</p>

<p>We also see that the parametric type <code class="language-plaintext highlighter-rouge">m</code> is further required to have a <code class="language-plaintext highlighter-rouge">MonadIO</code> instance. Fine, web connections are one form of I/O, so this makes some sense. What may be novel to some readers is that rather than being in the usual ‚Äúconcrete‚Äù form <code class="language-plaintext highlighter-rouge">.. -&gt; IO a</code>, the computation is ‚Äúlifted‚Äù to the MonadIO class, thus taking the form <code class="language-plaintext highlighter-rouge">MonadIO m =&gt; .. -&gt; m a</code>. It‚Äôs as if we went from saying ‚Äúa computation of type IO‚Äù to ‚Äúsomething of <em>any</em> type that can perform IO‚Äù.</p>

<p>The <code class="language-plaintext highlighter-rouge">MonadHttp</code> typeclass encodes exactly this: since HTTP connections are a form of I/O, the <code class="language-plaintext highlighter-rouge">MonadHttp</code> constraint <em>entails</em> the <code class="language-plaintext highlighter-rouge">MonadIO</code> constraint; in other words, every type <code class="language-plaintext highlighter-rouge">m</code> that has a <code class="language-plaintext highlighter-rouge">MonadHttp</code> instance <em>must</em> also declare a <code class="language-plaintext highlighter-rouge">MonadIO</code> instance (the compiler will complain otherwise).</p>

<p>We‚Äôll learn about the implications of this way of writing things in the following sections.</p>

<h2 id="api-authentication-and-type-families">API authentication and type families</h2>

<p>Many API providers require some form of authentication; during an initial ‚Äúhandshake‚Äù phase the client sends its credentials to the server over some secure channel (e.g. encrypted over TLS), which will in turn send back a ‚Äútoken‚Äù which will be necessary to perform the actual API calls and which will expire after a set time. This is for example how the OAuth2 authentication protocol works.</p>

<p>In practice, each provider has its own :</p>

<ul>
  <li>Set of credentials</li>
  <li>Authentication/token refresh mechanisms</li>
  <li>Handling of invalid input</li>
  <li>Request rate limiting</li>
  <li>Outage modes</li>
</ul>

<p>and so forth, however the general semantics of token-based authentication are common to all. This screams for some sort of common interface to hide the details of dealing with the individual providers from the rest of the application code.</p>

<p>One possible way of representing this is with a parametrized type; a way of declaring a computation that is ‚Äútagged‚Äù by the name of the API provider we‚Äôre talking to under the hood. Let‚Äôs call this type <code class="language-plaintext highlighter-rouge">Cloud</code>:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">newtype</span> <span class="kt">Cloud</span> <span class="n">c</span> <span class="n">a</span> <span class="o">=</span> <span class="o">...</span></code></pre></figure>

<p>The first type parameter, <code class="language-plaintext highlighter-rouge">c</code>, denotes the API provider ‚Äúlabel‚Äù, and the second parameter represents the result type of the computation.</p>

<p>Now, we need a way of saying ‚Äúfor each provider <code class="language-plaintext highlighter-rouge">c</code>, I need a specific set of <code class="language-plaintext highlighter-rouge">Credentials</code>, and I will receive a specific type of <code class="language-plaintext highlighter-rouge">Token</code> in return‚Äù; the TypeFamilies language extension lets us do just that :</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="cp">{-# language TypeFamilies #-}</span>

<span class="kr">class</span> <span class="kt">HasCredentials</span> <span class="n">c</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">Credentials</span> <span class="n">c</span>
  <span class="kr">type</span> <span class="kt">Token</span> <span class="n">c</span></code></pre></figure>

<p>In other words, the API provider label will be a distinct type, and we‚Äôll need to write a separate instance of <code class="language-plaintext highlighter-rouge">HasCredentials</code> (and corresponding concrete types for <code class="language-plaintext highlighter-rouge">Credentials</code> and <code class="language-plaintext highlighter-rouge">Token</code>) for each.</p>

<p>In addition, let‚Äôs write a <code class="language-plaintext highlighter-rouge">Handle</code> record type which will store the actual credentials and (temporary) token for a given provider:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">data</span> <span class="kt">Handle</span> <span class="n">c</span> <span class="o">=</span> <span class="kt">Handle</span> <span class="p">{</span>
    <span class="n">credentials</span> <span class="o">::</span> <span class="kt">Credentials</span> <span class="n">c</span>
  <span class="p">,</span> <span class="n">token</span> <span class="o">::</span> <span class="kt">Maybe</span> <span class="p">(</span><span class="kt">Token</span> <span class="n">c</span><span class="p">)</span>
  <span class="p">}</span></code></pre></figure>

<p>The types of the fields of <code class="language-plaintext highlighter-rouge">Handle</code> are associated (injectively) to the API provider type <code class="language-plaintext highlighter-rouge">c</code>. All that‚Äôs left at this point is to actually declare the <code class="language-plaintext highlighter-rouge">Cloud</code> type, which will use these <code class="language-plaintext highlighter-rouge">Handle</code>s. We‚Äôll see how in the next section.</p>

<h2 id="managing-application-complexity-with-types-and-monad-transformers">Managing application complexity with types and monad transformers</h2>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="cp">{-# language GeneralizedNewtypeDeriving #-}</span>

<span class="kr">newtype</span> <span class="kt">Cloud</span> <span class="n">c</span> <span class="n">a</span> <span class="o">=</span> <span class="kt">Cloud</span> <span class="p">{</span>
  <span class="n">runCloud</span> <span class="o">::</span> <span class="kt">ReaderT</span> <span class="p">(</span><span class="kt">Handle</span> <span class="n">c</span><span class="p">)</span> <span class="kt">IO</span> <span class="n">a</span>
  <span class="p">}</span> <span class="kr">deriving</span> <span class="p">(</span><span class="kt">Functor</span><span class="p">,</span> <span class="kt">Applicative</span><span class="p">,</span> <span class="kt">Monad</span><span class="p">)</span></code></pre></figure>

<p>The body of a <code class="language-plaintext highlighter-rouge">Cloud</code> computation is something which can <em>read</em> the data in <code class="language-plaintext highlighter-rouge">Handle</code> (for example the <code class="language-plaintext highlighter-rouge">credentials</code> or the <code class="language-plaintext highlighter-rouge">token</code>) and perform some I/O such as connecting to the provider. <code class="language-plaintext highlighter-rouge">ReaderT</code> is the ‚Äúreader‚Äù <a href="https://wiki.haskell.org/All_About_Monads#Monad_transformers">monad transformer</a>, in this case stacked ‚Äúon top‚Äù of IO. A monad transformer is a very handy way of interleaving effects, and a number of the most common ones are conveniently implemented in the <a href="https://hackage.haskell.org/package/mtl"><code class="language-plaintext highlighter-rouge">mtl</code></a> and <a href="https://hackage.haskell.org/package/transformers"><code class="language-plaintext highlighter-rouge">transformers</code></a> libraries.</p>

<p>The GeneralizedNewtypeDeriving language extension is necessary to make the compiler derive the Functor, Applicative and Monad instances for <code class="language-plaintext highlighter-rouge">Cloud</code>, which are very convenient for composing such computations together.</p>

<p>We may think of <code class="language-plaintext highlighter-rouge">Cloud c a</code> as an ‚Äúenvironment‚Äù or ‚Äúcontext‚Äù within which our networking logic gets executed. In more concrete terms, a <code class="language-plaintext highlighter-rouge">Cloud</code> computation needs to:</p>

<ul>
  <li>Read configuration (i.e. a variable of type <code class="language-plaintext highlighter-rouge">Handle c</code>)</li>
  <li>Create HTTP connections (i.e. I/O)</li>
  <li>Generate random numbers (since the token request is cryptographically hashed)</li>
  <li>Potentially throw and catch exceptions of some sort, for example when an API provider cannot find a certain piece of data.</li>
</ul>

<p>All the above <em>effects</em> can be ‚Äúlifted‚Äù to corresponding typeclasses, exactly as we saw with <code class="language-plaintext highlighter-rouge">MonadHTTP</code> and <code class="language-plaintext highlighter-rouge">MonadIO</code>. The <a href="https://hackage.haskell.org/package/exceptions"><code class="language-plaintext highlighter-rouge">exceptions</code></a> library provides <code class="language-plaintext highlighter-rouge">MonadThrow</code>/<code class="language-plaintext highlighter-rouge">MonadCatch</code>, <a href="https://hackage.haskell.org/package/cryptonite"><code class="language-plaintext highlighter-rouge">cryptonite</code></a> provides both all the cryptography primitives and the <code class="language-plaintext highlighter-rouge">MonadRandom</code> class, and <a href="https://hackage.haskell.org/package/mtl"><code class="language-plaintext highlighter-rouge">mtl</code></a> provides <code class="language-plaintext highlighter-rouge">MonadReader</code>.</p>

<p>We‚Äôll need to provide <code class="language-plaintext highlighter-rouge">Cloud</code> with instances of all these typeclasses (which most of the time boils down to implementing one or two methods for each), or in other words ‚Äúaugment it‚Äù with additional capabilities, in order to unify it with the constraints imposed by our network-related code.</p>

<p>I guess what I wrote above might sound super abstract, so let me provide an example. Suppose we have written a function that requests an authentication token; its type might look something like the following:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">requestToken</span> <span class="o">::</span> <span class="p">(</span><span class="kt">MonadHttp</span> <span class="n">m</span><span class="p">,</span> <span class="kt">MonadRandom</span> <span class="n">m</span><span class="p">,</span> <span class="kt">MonadThrow</span> <span class="n">m</span><span class="p">)</span> <span class="o">=&gt;</span>
     <span class="kt">TokenCredentials</span> <span class="o">-&gt;</span> <span class="kt">TokenOptions</span> <span class="o">-&gt;</span> <span class="n">m</span> <span class="kt">OAuth2Token</span></code></pre></figure>

<p>This alone already requires our ‚Äúexecution environment‚Äù <code class="language-plaintext highlighter-rouge">m</code> to have three of the constraints mentioned above. Suppose now we want to read the credentials and/or the options from an immutable record, which might be supplied e.g. by parsing a text file or some command line argument; we can do this if our <code class="language-plaintext highlighter-rouge">m</code> additionally has a <code class="language-plaintext highlighter-rouge">MonadReader</code> instance over the relevant configuration variable (e.g. <code class="language-plaintext highlighter-rouge">Handle c</code> declared above).</p>

<p>If, as we said, our <code class="language-plaintext highlighter-rouge">Cloud c a</code> type is enriched with these same instances, a complicated set of constraints such as</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">requestTokenProvider1</span> <span class="o">::</span> <span class="p">(</span><span class="kt">MonadReader</span> <span class="kt">TokenCredentials</span> <span class="n">m</span><span class="p">,</span> <span class="kt">MonadThrow</span> <span class="n">m</span><span class="p">,</span> <span class="kt">MonadHttp</span> <span class="n">m</span><span class="p">,</span> <span class="kt">MonadRandom</span> <span class="n">m</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="n">m</span> <span class="kt">OAuth2Token</span></code></pre></figure>

<p>might be rewritten as the more informative</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">requestTokenProvider1</span> <span class="o">::</span> <span class="kt">Cloud</span> <span class="kt">Provider1</span> <span class="kt">OAuth2Token</span></code></pre></figure>

<h1 id="long-overdue-aside--why-bother-">Long overdue aside : why bother ?</h1>

<p>This highly polymorphic way of writing functions might feel alien at first, but it lets us be as general <em>or</em> precise as we need to. In particular, one of the initial requirements I mentioned was the ability to talk independently about these external data providers, since each has a distinct behaviour and requires different information, but under one same interface.</p>

<p>The <code class="language-plaintext highlighter-rouge">Cloud c a</code> type is this interface. The parametrization over provider type <code class="language-plaintext highlighter-rouge">c</code> lets us declare the associated authentication types (with TypeFamilies) and separate implementations of the HTTP exception handling code, for example:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="cp">{-# language FlexibleInstances #-}</span>

<span class="kr">data</span> <span class="kt">Provider1</span>

<span class="kr">instance</span> <span class="kt">HasCredentials</span> <span class="kt">Provider1</span> <span class="kr">where</span>
  <span class="kr">type</span> <span class="kt">Credentials</span> <span class="kt">Provider1</span> <span class="o">=</span> <span class="kt">TokenCredentials</span>
  <span class="kr">type</span> <span class="kt">Token</span> <span class="kt">Provider1</span> <span class="o">=</span> <span class="kt">OAuth2Token</span>

<span class="kr">instance</span> <span class="kt">MonadHttp</span> <span class="p">(</span><span class="kt">Cloud</span> <span class="kt">Provider1</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">handleHttpException</span> <span class="n">e</span> <span class="o">=</span> <span class="o">...</span>

<span class="o">...</span> 

<span class="kr">data</span> <span class="kt">Provider2</span>

<span class="kr">instance</span> <span class="kt">MonadHttp</span> <span class="p">(</span><span class="kt">Cloud</span> <span class="kt">Provider2</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">handleHttpException</span> <span class="n">e</span> <span class="o">=</span> <span class="o">...</span>

<span class="o">...</span></code></pre></figure>

<p>while all the behaviour which is <em>shared</em> by all providers can be conveniently written once and for all (for example, random number generation) :</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="kr">instance</span> <span class="kt">HasCredentials</span> <span class="n">c</span> <span class="o">=&gt;</span> <span class="kt">MonadRandom</span> <span class="p">(</span><span class="kt">Cloud</span> <span class="n">c</span><span class="p">)</span> <span class="kr">where</span>
  <span class="n">getRandomBytes</span> <span class="o">=</span> <span class="n">liftIO</span> <span class="o">.</span> <span class="n">getEntropy</span></code></pre></figure>

<p>Reducing code duplication while allowing for flexibility where needed, while at the same time having the compiler warn us about every missing or overlapping implementation is a great feature to have for writing software with confidence, I think.</p>

<hr />

<p>Now we need a function to actually <em>run</em> <code class="language-plaintext highlighter-rouge">Cloud</code> computations. This is actually trivial: we extract the <code class="language-plaintext highlighter-rouge">ReaderT (Handle c) IO a</code> stuff that‚Äôs within the <code class="language-plaintext highlighter-rouge">Cloud</code> data constructor and apply it to <code class="language-plaintext highlighter-rouge">runReaderT</code> which passes in the given <code class="language-plaintext highlighter-rouge">Handle</code> data, thus configuring the computation:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">runCloudIO</span> <span class="o">::</span> <span class="kt">Handle</span> <span class="n">c</span> <span class="o">-&gt;</span> <span class="kt">Cloud</span> <span class="n">c</span> <span class="n">a</span> <span class="o">-&gt;</span> <span class="kt">IO</span> <span class="n">a</span>
<span class="n">runCloudIO</span> <span class="n">r</span> <span class="p">(</span><span class="kt">Cloud</span> <span class="n">body</span><span class="p">)</span> <span class="o">=</span> <span class="n">runReaderT</span> <span class="n">body</span> <span class="n">r</span></code></pre></figure>

<p>Since <code class="language-plaintext highlighter-rouge">Cloud</code> is an instance of Monad we can chain any number of such computations within a <code class="language-plaintext highlighter-rouge">do</code> block and wrap the overall computation in a <code class="language-plaintext highlighter-rouge">runCloudIO</code> call, which produces the result:</p>

<figure class="highlight"><pre><code class="language-haskell" data-lang="haskell"><span class="n">total</span> <span class="o">::</span> <span class="kt">HasCredentials</span> <span class="n">c</span> <span class="o">=&gt;</span> <span class="kt">Handle</span> <span class="n">c</span> <span class="o">-&gt;</span> <span class="kt">IO</span> <span class="n">a</span>
<span class="n">total</span> <span class="n">hdl</span> <span class="o">=</span> <span class="n">runCloudIO</span> <span class="n">hdl</span> <span class="o">$</span> <span class="kr">do</span> 
   <span class="n">x</span> <span class="o">&lt;-</span> <span class="n">cloudAuth</span>
   <span class="n">cloud2</span> <span class="n">x</span>
   <span class="n">y</span> <span class="o">&lt;-</span> <span class="n">cloud3</span> <span class="n">x</span>
   <span class="o">...</span></code></pre></figure>

<hr />

<p>This post is already pretty long so I will close it here, but there are a number of other topics that I care about and deserve a type-friendly treatment, for example exception handling and concurrency, as well as extremely useful libraries such as <code class="language-plaintext highlighter-rouge">async</code> and <code class="language-plaintext highlighter-rouge">stm</code> that I‚Äôd love to incorporate in this treatment.</p>

<p>Thank you for reading this far, I hope you enjoyed it and got something out of it. Feel free to reach out on twitter with feedback, comments, etc. Those are always welcome!</p>

:ET